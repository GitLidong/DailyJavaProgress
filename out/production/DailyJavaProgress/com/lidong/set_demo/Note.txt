/**
 * 集合框架
 * 
 * 			Abstract Collection   
 *                     |
 *      ----------------------------------------------
 *      |              |             |				 |
 * AbstractList  AbstractSet    AbstractQueue		 |		       AbstractMap
 * 		|   |          |             |               |                  |
 * 		|   |_____     |             |               |           -----------------
 * Abstract       |    |_______      |               |           |               |
 * Sequentialist  |    |       |     |               |           |               |
 *      |         | HashSet TreeSet  |               |           |               |
 *      |         |                  |               |           |               |
 *  LinkedList ArrayList        PriorityQueue    ArrayDeque   HashMap          TreeMap
 */
 
/*
 * 散列表（hash table)可以快速查找所需要的对象，也叫做哈希表。
 * 散列表为每个对象计算一个整数（hashCode)，称为散列码，散列码是由对象的实例域产生的一个整数，更准确的说是具有不同数据域的对象将产生不同的散列码。
 * （如果自定义类，就要负责实现这个类的hashCode方法。并且需要注意的是hasCode方法要与equals方法兼容。）
 * （最好使用String Integer这样的 Wrapper类作为键，String最常见，因为它不可变，也是final的，同时也重写过了 hasCode 和 equals方法）
 * Java中散列表用链表数组实现，每个列表被称为桶（bucket)。
 * 对象的位置，由对象的散列码与桶数取余，得到该对象的桶的索引。
 * 如果桶中没有其他元素，那么直接插入。
 * 如果有，那么发生散列冲突，这时需要用新对象与桶中的所有对象进行比较。如果已经有的话，会覆盖，没有的话有四种处理散列冲突的方法。
 * 以HashMap为例，HashMap用链表存储对象，所以这个值会被存储在后面的链表中。
 * 
 * 控制散列表的运行性能的话，要指定初始的桶数，通常设置为预计元素个数的 75% ~ 150% ， 并且最好将桶数设置为素数，防止键的集聚。
 * 
 * 如果散列表太慢，超过了负载因子（ load factor： 0.75为默认值）,即超过了 75%的位置都已经填入元素，那么需要再散列（rehashed)（翻倍？）
 * 
 * 散列表可以用于实现几个重要的数据结构，其中最简单的是set类型。set没有重复元素：HashSet、TreeSet
 * /
 
	/*
	 * Java提供了HashSet，add方法添加元素，contains方法查看是否包含元素。
	 * 散列集的迭代器将以此访问所有的桶，但由于散列将元素分散在表的各个位置，所以访问他们的顺序几乎是随机的。 只有不关心集合中元素的顺序时才使用HashSet。
	 */

	/*
	 * TreeSet 与散列集十分类似，但是树集是一个有序集合。可以按任意顺序插入元素，在集合进行遍历时，每个值将自动按照排序后的顺序呈现。
	 * TreeSet当前使用的是红黑树。 将一个元素添加到树中要比添加到散列表中慢，但是比添加到数组会链表中的正确位置还是快很多的。
	 * n个元素的树，添加元素时，查找新元素正确位置平均需要 log N 次比较。
	 * 
	 * 
	 * 默认情况下树集假定插入的元素实现了 Comparable 接口，通过 compareTo（T other)方法进行比较。 或者是自定义类实现了
	 * Comparator 接口，通过 compare(T a, T b)进行比较
	 */

/* * 
 * 
 * 
 * 集是一个集合，他可以快速查找现有的元素，但是要查看某个元素，就要有该元素的精确副本。
 * 
 * 所以用映射表（map)来存放键值对，可以根据键查找值。Java中映射表的通用实现： HashMap、TreeMap，他们两个实现了Map接口。
 * 散列映射表对键进行散列，树映射表用键的整体顺序对元素进行排序，并将其组织成搜索树。
 * 所以散列映射稍微快点，但是如果需要按照排序顺序访问键，就最好选择树映射表。
 * 
 * 映射表提供三个视图
 * 1. Set<K> keySet()
 * 2. Collection<K> values()
 * 3. Set<Map.Entry<K.V>> entrySet 
 */
 
 /**
 * 
 * @author LiDong
 *
 *         专用映射表类：
 *  1，弱散列映射表 WeakHashMap 如果有一个值，对应的键已经不再使用了，该值会出现什么情况？
 *         假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。
 *         但是由于在程序中的任何部分没有再出现这个键，所以，这个键值对无法从映射表中删除。
 *         因为垃圾回收器跟踪活动对象，只要映射表是活动的，齐总的所有桶也是活动的，他们不能被回收。
 *         因此需要程序负责对长期存活的映射表中删除那些无用的值，或者使用 WeakHashMap完成这件事。
 *
 *         WeakHashMap使用弱引用（weak
 *         reference）保存键，WeakReference对象将引用保存到另一个对象中，在这里就是散列表键。
 *         垃圾回收器对他们用特殊的方式处理，通常，如果gc发现某个特定的对象已经没有他人引用了，就将其回收。
 *         然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但将引用这个对象的引用放入队列中。
 *         WeakHashMap将周期性的检查队列，以便找出新添加的弱引用。一个若引用进入队列一位置这个键不再被他人使用，并且已经被收集起来。于是将删除对应的条目。
 *
 *
 *  2，链接散列集和链接映射表： LinkedHashSet LinkedHashMap 用来记住插入元素项的顺序。
 *         这样就可以避免在散列表中的项表面上看是随机排序的，当条目插入到表中，就会并入到双向链表中。
 *         
 *         
 *  3，枚举集与枚举映射表
 *  EnumSet 是一个枚举类型元素集的高效试下。由于枚举类型只有有限个实例，所以 EnumSet内部用位序列实现。
 *  如果对应的值在集中，则相应的位别职位1。
 *  EnumSet没有公共的构造器，可以用静态工厂方法构造这个集。
 *  
 *  EnumMap是一个键类型为枚举类型的映射表。他可以直接且高效的用一个值数组实现。
 *  
 *  
 *  4，标识散列映射表，IdentityHashMap。
 *   在这个类中，键的散列值不是hashCode()计算的，而是用 System.identityHashCode计算，是根据对象的内存地址来计算散列码
 *   而且，比较时候，IdentityHashMao使用 == 而不是equals
 * 也就是说，不同键对象，即使内容相同，也被视为不同的对象。
 * 在实现遍历算法时，这个类非常有用。
 */
 
-------------------------------------------------------------------------------------------------
 集合框架遗留类：
  
 	Stack                                         Properties
 	  |                                               |
 	Vector---------RandomAccess                   HashTable
 	  |                                               |
 AbstractList                                        Map
      |
    List
    
/**
 * 遗留的集合
 * 1，HashTable与HashMap类一样，但是是同步的。
 * 2，遗留集合使用Enumeration接口对集合进行遍历
 * 3，属性映射表 Properties，特殊的映射表结构，键 值都是字符串，表可以保存在文件中，也可以从文件读取，使用一个默认的辅助表。
 * 4，栈 Stack ,位集
 */